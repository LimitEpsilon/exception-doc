\documentclass{article}
\usepackage{geometry}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{kotex}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{ebproof}
\usepackage{fancyvrb}
\usepackage{biblatex}
\usepackage{csquotes}
\newtheorem{clm}{Claim}[section]
\addbibresource{citations.bib}

% fonts
\usepackage[math-style=TeX,bold-style=TeX]{unicode-math}

\usepackage{libertinus}

\newfontfamily{\fallbackfont}{EB Garamond}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\usepackage{newunicodechar}
\newunicodechar{⩴}{\textfallback{⩴}}

\setmainhangulfont{Noto Serif CJK KR}
\setsanshangulfont[BoldFont={* Bold}]{KoPubWorld Dotum.ttf}
\setmonohangulfont{D2Coding}

\usepackage{simplebnf}

% because of simplebnf
\newcommand\vbar{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{⩴}}
\newcommand*{\ortype}{\mathrel{|}}

% for complement
\newcommand{\loverbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}

\title{Constructing Set Constraints for ReScript}
\author{서울대학교 전기$\cdot$정보공학부 2018-12602 이준협}
\date{}
\begin{document}
\maketitle
\section{Definition of set expressions}
\begin{bnfgrammar}
  $se$ ::= $\varnothing$ : empty set
  | $\_$ : maximum set
  | $()$ : unit
  | $n$ : integer
  | $b$ : boolean
  | $\lambda x.e$ : function
  | $V_{e}$ : set variable corresponding to the possible values of $e$
  | $P_{e}$ : set variable corresponding to the possible exn packets of $e$
  | $\mathsf{body}_{V}(se)$ : values that $se$ can spit out when $se$ is applied to something
  | $\mathsf{body}_{P}(se)$ : exn packets that $se$ can spit out when $se$ is applied to something
  | $\mathsf{par}(se)$ : values that can be a parameter for $se$
  | $\kappa$ : constructor
  | $l$ : field of a record
  | $\mathsf{con}(\kappa,se)$ : construct
  | $\mathsf{exn}(\kappa,se)$ : exception
  | $\mathsf{fld}(se, l)$ : contents of the field $l$ of a record $se$
  | $\mathsf{cnt}(se)$ : contents of a reference
  | $\mathsf{bop}(se, se)$ : binary operators, where $\mathsf{bop}\in\{+, -, \times, \div, =, <, >\}$
  | $f^{-1}_{(i)}(se)$ : projection onto the i-th argument of $f$
  | $se \cup se$ : union
  | $se \cap se$ : intersection
  | $\loverbar{se}$ : complement
\end{bnfgrammar}

Case expressions need special concern when building set constraints. For example, take a look at the for loop.
\begin{figure}[htb]
\centering
\begin{BVerbatim}
let for x = match x > e2 with
            | true -> ()
            | false -> e3; for (x + 1)
in
for e1
\end{BVerbatim}
\end{figure}

The above program is equivalent to \texttt{for x = e1 to e2 do e3 done}. Translating this is difficult as case statements partition the program states.
That is, ``\texttt{e3; for (x + 1)}'' is evaluated under the constraint that $>(V_{x},V_{e_{2}})\subseteq \mathtt{false}$ and ``\texttt{()}'' is evaluated under the constraint that $>(V_{x}, V_{e_{2}})\subseteq \mathtt{true}$.

These constraints obviously cannot be \texttt{and}-ed together, as the result is trivially \texttt{false}. Since the constraints above partition the program states, it is straightforward that each set expression must have different ``versions'' of itself in each partition.

So each case statement creates a parallel world where some set constraint becomes true.

\section{Constructing set constraints}

Now we are in a position to define constraint construction rules for our ReScript-like language. Hopefully this would be reasonably fast when implemented and be accurate enough...

\begin{center}
\begin{prooftree}
    \infer[left label={UNIT, INT, BOOL}]0[$c=(),n,b$] {\rhd c \colon V_{e}\supseteq c}
\end{prooftree}

\begin{prooftree}
  \hypo{\rhd e_{1} \colon C_{1}}
  \hypo{\rhd e_{2} \colon C_{2}}
  \infer[left label={APP}]2{\rhd e_{1} \: e_{2} \colon (V_{e}\supseteq \mathsf{body}_{V}(V_{e_{1}}))\wedge
    (P_{e}\supseteq (\mathsf{body}_{P}(P_{e_{1}}) \cup P_{e_{1}} \cup P_{e_{2}})) \wedge
    (\mathsf{par}(V_{e_{1}}) \supseteq V_{e_{2}})\wedge
    C_{1}\wedge
    C_{2}}
\end{prooftree}

\begin{prooftree}
  \hypo{\rhd e' \colon C'}
  \infer[left label={FN}]1{\rhd \lambda x.e' \colon (V_{e}\supseteq \lambda x.e')\wedge
    (\mathsf{body}_{V}(V_{e})\supseteq V_{e'})\wedge
    (\mathsf{body}_{P}(V_{e})\supseteq P_{e'})\wedge
    (\mathsf{par}(V_{e})\subseteq V_{x})\wedge
    C'}
\end{prooftree}

\begin{prooftree}
  \hypo{\rhd e_1 \colon C_1}
  \hypo{\rhd e_2 \colon C_2}
  \infer[left label={LET}]2{\rhd let \: x=e_1 \: in \: e_2 \colon
    (V_x \supseteq V_{e_1})\wedge
    (P_x \supseteq P_{e_2})\wedge
    }
\end{prooftree}
\end{center}

\printbibliography
\end{document}
