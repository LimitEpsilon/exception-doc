\documentclass{article}
\usepackage{geometry}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{kotex}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{ebproof}
\usepackage{fancyvrb}
\usepackage{biblatex}
\usepackage{csquotes}
\usepackage{multicol}
\newtheorem{clm}{Claim}[section]
\addbibresource{citations.bib}

% fonts
\usepackage[math-style=TeX,bold-style=TeX]{unicode-math}

\usepackage{libertinus}

\newfontfamily{\fallbackfont}{EB Garamond}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\usepackage{newunicodechar}
\newunicodechar{⩴}{\textfallback{⩴}}

\setmainhangulfont{Noto Serif CJK KR}
\setsanshangulfont[BoldFont={* Bold}]{KoPubWorld Dotum.ttf}
\setmonohangulfont{D2Coding}

\usepackage{simplebnf}

% because of simplebnf
\newcommand\vbar{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{⩴}}
\newcommand*{\ortype}{\mathrel{|}}

% for complement
\newcommand{\loverbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}

\title{Constructing Set Constraints for ReScript}
\author{서울대학교 전기$\cdot$정보공학부 이재호, 이준협}
\date{}
\begin{document}
\maketitle
\section{Definition of set expressions}
\begin{bnfgrammar}
  $se$ ::= $\varnothing$ : empty set
  | $\_$ : maximum set
  | $()$ : unit
  | $n$ : integer
  | $b$ : boolean
  | $\langle\lambda x.e,\sigma\rangle$ : closure
  | $\mathsf{loc}$ : memory location
  | $V(e,\sigma)$ : set variable corresponding to the possible values of $e$ under $\sigma$
  | $P(e,\sigma)$ : set variable corresponding to the possible exn packets of $e$ under $\sigma$
  | $\mathsf{app}_{V}(se,e)$ : values that $se$ can spit out when $se$ is applied to $e$
  | $\mathsf{app}_{P}(se,e)$ : exn packets that $se$ can spit out when $se$ is applied to $e$
  | $\mathsf{con}(\kappa,se)$ : construct
  | $\mathsf{exn}(\kappa,se)$ : exception
  | $\mathsf{fld}(se, l)$ : contents of the field $l$ of a record $se$
  | $\mathsf{cnt}(se)$ : contents of a reference
  | $\mathsf{bop}(se, se)$ : binary operators, where $\mathsf{bop}\in\{+, -, \times, \div, =, <, >\}$
  | $f^{-1}_{(i)}(se)$ : projection onto the i-th argument of $f$
  | $se \cup se$ : union
  | $se \cap se$ : intersection
  | $\loverbar{se}$ : complement
  | $se \Rightarrow se$ : conditional expression
\end{bnfgrammar}

The definition of the conditional set expression needs clarification.

\[
  (se_{1} \Rightarrow se_{2}) \coloneq
  \begin{cases}
    \varnothing & (se_{1}=\varnothing)\\
    se_{2} & (o.w)
  \end{cases}
\]

The conditional set expression is a naive approximation for pattern matching. Consider the case when we want to match an expression against the record pattern with fields $x$ and $y$.
The constraints describing the record $r = \{x = 1, y = 2\}$ are $1 \subseteq \mathsf{fld}(V(r,\sigma_{r}), x) \wedge 2 \subseteq \mathsf{fld}(V(r,\sigma_{r}), y)$ with $\sigma_{r}=[r\mapsto\{x=1, y=2\}]$.
To pattern-match $r$ against $\{x, y\}$, we want the fields $x$ and $y$ of $V(r,\sigma_{r})$ to be nonempty.
Thus, the value of ``$match\:r\:with\:\{x, y\}\rightarrow e$'' is $\mathsf{fld}(V(r,\sigma_{r}), x)\Rightarrow(\mathsf{fld}(V(r,\sigma_{r}),y)\Rightarrow V(e,\sigma_{e}))$.

The conditional set expression can also be used to define conditional set constraints \cite{Aik99}.
\[
  \left(se \Rightarrow \left(\bigwedge_{i=1}^{n}{X_{i}\subseteq Y_{i}}\right)\right) \coloneq \bigwedge_{i=1}^{n}{(se \Rightarrow X_{i}) \subseteq Y_{i}}
\]

\section{Constructing set constraints}

Now we are in a position to define constraint construction rules for our ReScript-like language. Hopefully this would be reasonably fast when implemented and be accurate enough...

Notation: $\sigma_{i}\coloneq\sigma\vbar_{e_{i}}$, $E_{x}$: expression variable, $\Sigma_{x}$: environment variable, all \textit{Expr}s are tagged with their location

\begin{center}
\begin{prooftree}
    \infer[left label={[UNIT, INT, BOOL]}]0[$c=(),n,b$] {[]\rhd c \colon V(e,\sigma)\supseteq c}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma_{1}\rhd e_{1} \colon C_{1}}
  \hypo{\sigma_{2}\rhd e_{2} \colon C_{2}}
  \infer[left label={[APP]}]2{
    {\begin{array}{r l}\sigma\rhd e_{1} \: e_{2} \colon & V(e,\sigma)\supseteq \mathsf{app}_{V}(V(e_1,\sigma_{1}),e_2) \: \wedge \\ &
    P(e,\sigma)\supseteq \mathsf{app}_{P}(V(e_1,\sigma_1),e_2) \cup P(e_1,\sigma_1) \cup P(e_2,\sigma_2) \wedge
    C_{1}\wedge
    C_{2}\end{array}}}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma \cup [x\mapsto E_x] \rhd e' \colon C'}
  \infer[left label={[FN]}]1{
    {\begin{array}{r l}
    \sigma \rhd \lambda x.e' \colon V(e,\sigma)\supseteq \langle\lambda x.e',\sigma\rangle \: \wedge &
    \mathsf{app}_{V}(\langle\lambda x.e',\sigma\rangle,E_x)\supseteq V(e',[x\mapsto E_x] \cup \sigma) \: \wedge \\ &
    \mathsf{app}_{P}(\langle\lambda x.e',\sigma\rangle,E_x)\supseteq P(e',[x\mapsto E_x] \cup \sigma) \wedge
    C'
    \end{array}}}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \infer[left label={[VAR]}]0{
    \sigma \rhd x \colon V(x, \sigma)\supseteq V(\sigma(x),\Sigma_x)}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma_1 \cup \overbrace{[x \mapsto e_1]}^{\text{support rec}} \rhd e_1 \colon C_1}
  \hypo{\sigma_2 \cup [x \mapsto e_1] \rhd e_2 \colon C_2}
  \infer[left label={[LET]}]2{
    {\begin{array}{r l}
    \sigma\rhd \text{let }x=e_1 \text{ in } e_2 \colon
    & V(e,\sigma) \supseteq V(e_2, \sigma_2 \cup [x \mapsto e_1])\:\wedge \\
    & P(e,\sigma) \supseteq P(e_1, \sigma_1 \cup [x \mapsto e_1]) \cup P(e_2, \sigma_2 \cup [x \mapsto e_1])\wedge
    C_1\wedge C_2
    \end{array}}
    }
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma_1 \rhd e_1 \colon C_1}
  \hypo{\sigma_2 \rhd e_2 \colon C_2}
  \infer[left label={[BOP]}]2{
    {\begin{array}{r l}
       \sigma \rhd e_1 \: \mathsf{bop} \: e_2 \colon
       & V(e,\sigma) \supseteq \mathsf{bop}(V(e_1,\sigma_1), V(e_2,\sigma_2))\:\wedge \\
       & P(e,\sigma) \supseteq P(e_1,\sigma_1)\cup P(e_2,\sigma_2)\wedge
       \underbrace{P(e,\sigma) \supseteq (V(e_2,\sigma_2)\cap 0 \Rightarrow \mathsf{exn}(\mathsf{Divide\_by\_zero}, ()))}_{\text{when bop is }\div}\wedge
       C_1 \wedge C_2
    \end{array}}}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma \rhd e' \colon C'}
  \infer[left label={[CON]}]1{\sigma \rhd \mathsf{con}\: \kappa \: e'\colon
    V(e,\sigma) \supseteq \mathsf{con}(\kappa , V(e',\sigma))\wedge
    P(e,\sigma) \supseteq P(e',\sigma)\wedge
    C'}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma \rhd e' \colon C'}
  \infer[left label={[EXN]}]1{\sigma \rhd \mathsf{exn}\: \kappa \: e' \colon
    V(e,\sigma) \supseteq \mathsf{exn}(\kappa, V(e',\sigma))\wedge
    P(e,\sigma) \supseteq P(e',\sigma)\wedge
    C'}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma \rhd e' \colon C'}
  \infer[left label={[DECON]}]1[as in SML-NJ's Lambda]{
    {\begin{array}{r l}
       \sigma\rhd \mathsf{decon}\:\kappa\: e' \colon &
       V(e,\sigma) \supseteq
       \mathsf{con}^{-1}_{(2)}(\underbrace{V(e',\sigma)\cap \mathsf{con}(\kappa, \_)}_{\text{filter}})
       \cup
       \mathsf{exn}^{-1}_{(2)}(\underbrace{V(e',\sigma)\cap \mathsf{exn}(\kappa, \_)}_{\text{filter}})\:\wedge \\
       & P(e,\sigma) \supseteq P(e',\sigma) \wedge
       C'
     \end{array}}}
\end{prooftree}

\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma_{i}\rhd e_i \colon C_i \: (1 \leq i \leq n)}
  \infer[left label={[RECORD]}]1{\sigma \rhd \{l_1=e_i,...,l_n=e_n\} \colon
    \bigwedge_{i=1}^{n}{(\mathsf{fld}(V(e,\sigma), l_i) \supseteq V(e_i,\sigma_i))}\wedge
    P(e,\sigma) \supseteq \bigcup_{i=1}^{n}{P(e_i,\sigma_i)}\wedge
    \bigwedge_{i=1}^{n}{C_i}}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma \rhd e' \colon C'}
  \infer[left label={[FIELD]}]1{\sigma \rhd e'.l \colon
    V(e,\sigma) \supseteq \mathsf{fld}(V(e',\sigma), l)\wedge
    P(e,\sigma) \supseteq P(e',\sigma)\wedge
    C'
  }
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma\rhd e' \colon C'}
  \infer[left label={[REF]}]1[new loc]{\sigma \rhd \mathsf{ref}\: e' \colon
    V(e,\sigma) \supseteq \mathsf{loc} \wedge
    \mathsf{cnt}(\mathsf{loc})\supseteq V(e',\sigma) \wedge
    P(e,\sigma) \supseteq P(e',\sigma)\wedge
    C'}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma_1 \rhd e_1 \colon C_1}
  \hypo{\sigma_2 \rhd e_2 \colon C_2}
  \infer[left label={[UPDATE]}]2{\sigma \rhd e_1 := e_2 \colon
    \mathsf{cnt}(V(e_1,\sigma_1))\supseteq V(e_2,\sigma_2) \wedge
    P_e \supseteq P(e_1,\sigma_1)\cup P(e_2,\sigma_2)\wedge
    C_1 \wedge
    C_2}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma \rhd e' \colon C'}
  \infer[left label={[BANG]}]1{\sigma \rhd !e' \colon
    V(e,\sigma) \supseteq \mathsf{cnt}(V(e',\sigma))\wedge
    P(e,\sigma) \supseteq P(e',\sigma)\wedge
    C'}
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma_1 \rhd e_1 \colon C_1}
  \hypo{\sigma_2 \rhd e_2 \colon C_2}
  \infer[left label={[SEQ]}]2{\sigma \rhd e_1 ; e_2 \colon
    V(e,\sigma) \supseteq V(e_2,\sigma_2)\wedge
    P(e,\sigma) \supseteq P(e_1,\sigma_1)\cup P(e_2,\sigma_2)\wedge
    C_1 \wedge
    C_2
  }
\end{prooftree}
\end{center}

We define an auxilary function for generating constraints out of pattern matching.
If we want to figure out the constraint for the expression $e=$ ``$\mathsf{match}\: e' \: \mathsf{with}\: p\rightarrow e''$'' under $\sigma$:

\[
\mathsf{case}(e',\sigma,p,e'')\coloneq
\begin{cases}
  V(e,\sigma) \supseteq V(e'',\sigma\vbar_{e''} \cup [x \mapsto e']) & (p=x)\\
  V(e,\sigma) \supseteq V(e'',\sigma\vbar_{e''}) & (o.w)
\end{cases}
\]

\begin{center}
\begin{prooftree}
  \hypo{\sigma\vbar_{e'}\rhd e' \colon C'}
  \hypo{\sigma_{i}\rhd e_i \colon C_i \: (1\leq i \leq n)}
  \infer[left label={[CASE]}]2{\sigma\rhd \mathsf{case}\: e' \: \left(p_i \rightarrow e_i\right)_{i=1}^{n}\colon
    \bigwedge_{i=1}^{n}\mathsf{case}(e',\sigma,p_i,e_i)\wedge
    P(e,\sigma) \supseteq \bigcup_{i=1}^{n}P(e_i,\sigma_i) \cup P(e',\sigma\vbar_{e'})\wedge
    C'\wedge
    \bigwedge_{i=1}^{n}C_i
  }
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma\vbar_{e'}\rhd e' \colon C'}
  \hypo{\sigma_{i}\rhd e_i \colon C_i \: (1\leq i \leq n)}
  \infer[left label={[HANDLE]}]2{
    {\begin{array}{r l}
       \sigma\rhd \mathsf{handle}\: e' \: \left(p_i \rightarrow e_i\right)_{i=1}^{n}\colon
       &P(e,\sigma) \supseteq (P(e',\sigma\vbar_{e'})\cap\bigcap_{i=1}^{n}\loverbar{\mathsf{exn}(p_i, \_)})\cup \bigcup_{i=1}^{n}P(e_i,\sigma_i)\:\wedge\\
       &V(e,\sigma) \supseteq V(e',\sigma\vbar_{e'})\cup \bigcup_{i=1}^{n}{V(e_i,\sigma_i)}\:\wedge\\
       &C'\wedge \bigwedge_{i=1}^{n}C_i
    \end{array}}
  }
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma\rhd e' \colon C'}
  \infer[left label={[RAISE]}]1{\sigma\rhd \mathsf{raise}\: e' \colon
    P(e,\sigma) \supseteq V(e',\sigma)\cup P(e',\sigma)\wedge
    C'
  }
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma_1 \rhd e_1 \colon C_1}
  \hypo{\sigma_2 \rhd e_2 \colon C_2}
  \hypo{\sigma_3 \cup [x \mapsto e_1] \rhd e_3 \colon C_3}
  \hypo{\sigma_3 \cup [x \mapsto x+1] \rhd e_3 \colon C_4}
  \infer[left label={[FOR]}]4{
    {\begin{array}{r l}
       \sigma \rhd \mathsf{for\:}x\: e_1\: e_2\: e_3 \colon
       &V(e,\sigma) \supseteq () \wedge V(x, [x \mapsto e_1]) \supseteq V(e_1, \sigma_1) \: \wedge \\
       &V(x, [x \mapsto x+1]) \supseteq +(V(e_1, \sigma_1), 1) \cup +(V(x, [x\mapsto x + 1]), 1)\: \wedge\\
       &P(e,\sigma) \supseteq P(e_1, \sigma_1)\cup P(e_2,\sigma_2)\cup P(e_3,\sigma_3 \cup [x \mapsto e_1]) \cup P(e_3, \sigma_3 \cup [x \mapsto x + 1])\:\wedge\\
       &C_1 \wedge C_2 \wedge C_3 \wedge C_4
    \end{array}}
  }
\end{prooftree}
\vspace{0.2cm}

\begin{prooftree}
  \hypo{\sigma_1 \rhd e_1 \colon C_1}
  \hypo{\sigma_2 \rhd e_2 \colon C_2}
  \infer[left label={[WHILE]}]2{
       \sigma \rhd \mathsf{while\:}e_1 \: e_2 \colon
       V(e,\sigma) \supseteq () \wedge P(e,\sigma) \supseteq P(e_1,\sigma_1)\cup P(e_2,\sigma_2) \wedge C_1 \wedge C_2}
\end{prooftree}
\end{center}

\section{Example}

\[
\underbrace{\text{let }f = \overbrace{\lambda x.\underbrace{\text{Error } \overbrace{(\underbrace{f}_{e_{11}''} \underbrace{x}_{e_{12}''})}^{e_{1}''}}_{e_{1}'}}^{e_{1}}\text{ in }\overbrace{\text{raise } \underbrace{(\overbrace{f}^{e_{21}'} \overbrace{\text{Fail}}^{e_{22}'})}_{e_{2}'}}^{e_{2}}}_{e}
\]

The above program is type checked as $f:\mathsf{exn}\rightarrow \mathsf{exn}$, yet it does not terminate. The (simplified) set constraints generated for this program are:

\[
\begin{array}{l c c c}
  \text{Constraint} & \text{From} & \text{By} & \text{No.}\\
  \hline
  P(e, []) \supseteq P(e_{2},[f\mapsto e_{1}]) & e & \text{[LET]} & (1)\\
  V(e_{1},[f\mapsto e_{1}]) \supseteq \langle \lambda x.e_{1}' , [f \mapsto e_{1}]\rangle & e_{1} & \text{[FN]} & (2)\\
  \mathsf{app}_{V}(\langle \lambda x.e_{1}' , [f \mapsto e_{1}]\rangle, E_{x}) \supseteq V(e_{1}',[f \mapsto e_{1};x \mapsto E_{x}]) & e_{1} & \text{[FN]} & (3)\\
  V(e_{1}',[f \mapsto e_{1};x \mapsto E_{x}]) \supseteq \mathsf{exn}(\text{Error},V(e_{1}'', [f \mapsto e_{1};x \mapsto E_{x}])) & e_{1}' & \text{[EXN]} & (4)\\
  V(e_{1}'',[f \mapsto e_{1};x \mapsto E_{x}]) \supseteq \mathsf{app}_{V}(V(e_{11}'', [f \mapsto e_{1}]), e_{12}'') & e_{1}'' & \text{[APP]} & (5)\\
  V(e_{11}'', [f \mapsto e_{1}]) \supseteq V(e_{1},\Sigma_{f}) & e_{11}'' & \text{[VAR]} & (6)\\
  V(e_{12}'', [x \mapsto E_{x}]) \supseteq V(E_{x},\Sigma_{x}) & e_{12}'' & \text{[VAR]} & (7)\\
  P(e_{2},[f \mapsto e_{1}]) \supseteq V(e_{2}',[f \mapsto e_{1}]) & e_{2} & \text{[RAISE]} & (8)\\
  V(e_{2}', [f \mapsto e_{1}]) \supseteq \mathsf{app}_{V}(V(e_{21}', [f \mapsto e_{1}]), e_{22}') & e_{2}' & \text{[APP]} & (9)\\
  V(e_{21}', [f \mapsto e_{1}]) \supseteq V(e_{1},\Sigma_{f}) & e_{21}' & \text{[VAR]} & (10)\\
  V(e_{22}', []) \supseteq \mathsf{exn}(\text{Fail}, ()) & e_{22}' & \text{[EXN]} & (11)
\end{array}
\]

To ``solve'' this system of constraints, multiple reduction steps are needed.

\begin{enumerate}
  \item
        \begin{align*}
          V(e_{2}',[f \mapsto e_{1}])
          &\supseteq \mathsf{app}_{V}(V(e_{21}',[f \mapsto e_{1}]),e_{22}') & (\because (9))\\
          &\supseteq \mathsf{app}_{V}(V(e_{1},\Sigma_{f}),e_{22}') & (\because (10))\\
          &\supseteq \mathsf{app}_{V}(V(e_{1},[f\mapsto e_{1}]),e_{22}') & (\text{unify with }(2))\\
          &\supseteq \mathsf{app}_{V}(\langle \lambda x. e_{1}',[f \mapsto e_{1}]\rangle , e_{22}') & (\because (2))\\
          &\supseteq V(e_{1}',[f\mapsto e_{1};x\mapsto e_{22}']) & (\because (3))
        \end{align*}
  \item
        \begin{align*}
          V(e_{1}',[f\mapsto e_{1};x\mapsto e_{22}'])
          &\supseteq \mathsf{exn}(\text{Error},V(e_{1}'',[f\mapsto e_{1};x\mapsto e_{22}'])) & (\because (4))
        \end{align*}
  \item
        \begin{align*}
          V(e_{1}'',[f\mapsto e_{1};x\mapsto e_{22}'])
          &\supseteq \mathsf{app}_{V}(V(e_{11}'',[f\mapsto e_{1}]),e_{12}'') & (\because (5))\\
          &\supseteq \mathsf{app}_{V}(V(e_{1},\Sigma_{f}),e_{12}'') & (\because (6))\\
          &\supseteq \mathsf{app}_{V}(V(e_{1},[f\mapsto e_{1}]),e_{12}'') & (\text{unify with }(2))\\
          &\supseteq \mathsf{app}_{V}(\langle \lambda x.e_{1}',[f\mapsto e_{1}]\rangle,e_{12}'') & (\because (2))\\
          &\supseteq V(e_{1}',[f \mapsto e_{1};x \mapsto e_{12}'']) & (\because (3))
        \end{align*}
  \item
        \begin{align*}
          V(e_{1}',[f \mapsto e_{1};x \mapsto e_{12}''])
          &\supseteq \mathsf{exn}(\text{Error},V(e_{1}'',[f\mapsto e_{1};x\mapsto e_{12}''])) & (\because (4))
        \end{align*}
  \item
        \begin{align*}
          V(e_{1}'',[f\mapsto e_{1};x\mapsto e_{12}''])
          &\supseteq \mathsf{app}_{V}(V(e_{11}'',[f\mapsto e_{1}]),e_{12}'') & (\because (5))\\
          &\supseteq V(e_{1}',[f\mapsto e_{1};x\mapsto e_{12}'']) & (\text{as in }3)
        \end{align*}
  \item Cannot reduce further as $V(e_{1}',[f \mapsto e_{1};x\mapsto e_{12}''])$ was already reduced in 4.
\end{enumerate}

Let $X_{1}\coloneq V(e_{1}',[f\mapsto e_{1};x\mapsto e_{22}'])$, $X_{2}\coloneq V(e_{1}'',[f\mapsto e_{1};x\mapsto e_{22}'])$, $X_{3}\coloneq V(e_{1}',[f\mapsto e_{1};x\mapsto e_{12}''])$, $X_{4}\coloneq V(e_{1}'',[f\mapsto e_{1};x\mapsto e_{12}''])$. Then the equations reduce to:

\begin{align*}
  P(e,[])\supseteq P(e_{2},[f\mapsto e_{1}])&\supseteq V(e_{2}',[f\mapsto e_{1}]) & (\because (1),(8))\\
  V(e_{2}',[f\mapsto e_{1}])&\supseteq X_{1} & (\because 1)\\
  \Rightarrow P(e,[])&\supseteq X_{1} & \\
  X_{1}&\supseteq \mathsf{exn}(\text{Error},X_{2}) & (\because 2)\\
  X_{2}&\supseteq X_{3} & (\because 3)\\
  X_{3}&\supseteq \mathsf{exn}(\text{Error},X_{4}) & (\because 4)\\
  X_{4}&\supseteq X_{3} & (\because 5)
\end{align*}

Note that constraint (7) was not used in the derivation of the above relations. This reflects the fact that the program does not terminate. There is absolutely no execution path evaluating what ``Fail'' is.

\section{Why $\sigma$?}

Wrapper function around raise. $e$ is actually the location in code. Need a hash table between $e$ and location.

TODO:
\begin{enumerate}
  \item How to solve the set constraints(first in the case when there are no conditional expressions) : based on the work of Nevin Heintze\cite{Hei91}
  \item Maybe, how to formulate the ``parallel worlds'' approach?
\end{enumerate}
\printbibliography
\end{document}
